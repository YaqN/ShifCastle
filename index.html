<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ðŸŽ‚ Castle Door 3D Birthday Gallery</title>
  <meta name="description" content="Open the castle doors and walk into a 3D hallway of framed photos for a birthday gift."/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#201226; --ink:#f9eef9; --gold:#f2d38b; --rose:#e7a6c9; --violet:#3a1c4a;
    }
    html,body{height:100%;}
    body{margin:0; background: radial-gradient(1200px 800px at 50% -10%, #3c2150 0%, #261431 40%, #18101f 80%, #100a15 100%); color:var(--ink); font-family: 'IM Fell English', serif; overflow:hidden;}
    #ui{ position:fixed; inset: 0 auto auto 0; z-index:10; padding:12px 14px; display:flex; gap:10px; align-items:center; }
    .brand{display:flex; align-items:center; gap:10px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:8px 12px; backdrop-filter: blur(8px);}
    .brand b{font-family:'Cinzel Decorative', serif; letter-spacing:.02em; color:var(--gold)}
    .hint{position:fixed; left:50%; transform: translateX(-50%); bottom:18px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:8px 14px; font-size:14px; opacity:.9}
    .btn{cursor:pointer; border-radius:999px; padding:8px 12px; border:1px solid rgba(255,255,255,.18); background:linear-gradient(180deg, rgba(255,255,255,.2), rgba(255,255,255,.06)); color:#fff; font-weight:700; letter-spacing:.02em;}
    .btn:hover{filter:brightness(1.1)}
    #loading{ position:fixed; inset:0; display:grid; place-items:center; background: radial-gradient(circle at 50% 40%, #1f132a 0%, #100913 70%); z-index:50;}
    .spinner{ width:64px; height:64px; border-radius:50%; border:4px solid rgba(255,255,255,.15); border-top-color: var(--gold); animation: spin 1s linear infinite;}
    @keyframes spin{ to{ transform: rotate(360deg)} }
    /* Lightbox */
    #lightbox{ position:fixed; inset:0; background: rgba(5,3,8,.9); display:none; align-items:center; justify-content:center; z-index:40;}
    #lightbox.open{ display:flex; }
    .lb-card{ max-width:min(1100px, 96vw); width:100%; background:#0f0a12; border:1px solid #3b2a4a; border-radius:14px; overflow:hidden; box-shadow: 0 30px 80px rgba(0,0,0,.7);}
    .lb-img{ display:block; width:100%; max-height:78vh; object-fit:contain; background:#0b0710;}
    .lb-meta{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; color:#cbb8cf; }
    .lb-close{ all:unset; cursor:pointer; padding:6px 10px; border-radius:8px; border:1px solid #5a3a6a; }
  </style>
</head>
<body>
  <div id="loading"><div class="spinner" aria-label="Loading"></div></div>
  <div id="ui" aria-hidden="true">
    <div class="brand">ðŸ‘‘ <b>Castle Birthday Gallery</b></div>
    <button id="btnReset" class="btn" title="Reset">Reset</button>
  </div>
  <div class="hint" id="hint">Click the golden doors âœ¨</div>

  <!-- Lightbox for viewing a frame image -->
  <div id="lightbox" role="dialog" aria-modal="true" aria-label="Photo viewer" aria-hidden="true">
    <div class="lb-card">
      <img id="lbImg" class="lb-img" alt="Large photo" />
      <div class="lb-meta">
        <div id="lbCaption">Happy Birthday! ðŸŽ‚</div>
        <button id="lbClose" class="lb-close">Close âœ•</button>
      </div>
    </div>
  </div>

  <canvas id="scene"></canvas>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // =========================
  // CONFIG: put your photos here
  // =========================
  const PHOTOS = [
    // Replace these with your birthday photos (direct image URLs)
  { src: "birthday_center.png", caption: "2005â€™s Angel â€” Heart cake" },
  { src: "bunny_room.jpg", caption: "Soft bunny and tea" },
  { src: "cake_room.jpg", caption: "Floral cake and tea moment" },
  { src: "tea_room.jpg", caption: "Morning tea & croissant" }
];


  // Basic three.js setup
  const canvas = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x120a1a, 18, 120);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
  camera.position.set(0, 2, 14);
  scene.add(camera);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.enabled = false; // will enable after door opens

  // Lights
  const hemi = new THREE.HemisphereLight(0xffe1ff, 0x150b13, 0.8);
  scene.add(hemi);
  const keyLight = new THREE.SpotLight(0xf2d38b, 2, 60, Math.PI/6, 0.4, 1.2);
  keyLight.position.set(0, 6, 10);
  keyLight.target.position.set(0, 3, 0);
  scene.add(keyLight, keyLight.target);

  // Floor and corridor materials
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x3b2a4a, roughness: 0.95, metalness: 0.05 });
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x2a1936, roughness: 0.9 });
  const trimMat = new THREE.MeshStandardMaterial({ color: 0x8a6b2f, metalness: 0.8, roughness: 0.2 });

  // Castle faÃ§ade with double doors
  const facade = new THREE.Group();
  const facadeWall = new THREE.Mesh(new THREE.BoxGeometry(14, 8, 1), wallMat);
  facadeWall.position.set(0, 4, 0);
  facade.add(facadeWall);

  // Arch
  const archGeom = new THREE.RingGeometry(0, 3.2, 32, 1, Math.PI, Math.PI);
  const arch = new THREE.Mesh(archGeom, trimMat);
  arch.position.set(0, 6.4, 0.51);
  arch.rotation.x = Math.PI; // face forward
  facade.add(arch);

  // Doors (left & right)
  const doorMat = new THREE.MeshStandardMaterial({ color: 0xb78b33, metalness: 0.6, roughness: 0.35 });
  const doorGeom = new THREE.BoxGeometry(1.6, 3.6, 0.08);
  const doorLeft = new THREE.Mesh(doorGeom, doorMat);
  const doorRight = new THREE.Mesh(doorGeom, doorMat);
  doorLeft.position.set(-0.8, 2.2, 0.55);
  doorRight.position.set(0.8, 2.2, 0.55);
  // Set hinges by grouping
  const hingeL = new THREE.Group(); hingeL.position.set(-1.6, 2.2, 0.55); // hinge on left outer edge
  const hingeR = new THREE.Group(); hingeR.position.set(1.6, 2.2, 0.55);
  doorLeft.position.x = 0.8; doorRight.position.x = -0.8; // offset inside hinge group
  hingeL.add(doorLeft); hingeR.add(doorRight);
  facade.add(hingeL, hingeR);

  // Simple doorknobs
  const knobGeom = new THREE.SphereGeometry(0.08, 16, 16);
  const knobMat = new THREE.MeshStandardMaterial({ color: 0xf2d38b, metalness: 1, roughness: 0.15 });
  const knobL = new THREE.Mesh(knobGeom, knobMat); knobL.position.set(0.05, 0, 0.06); doorLeft.add(knobL);
  const knobR = new THREE.Mesh(knobGeom, knobMat); knobR.position.set(-0.05, 0, 0.06); doorRight.add(knobR);

  facade.position.set(0, 0, 0);
  scene.add(facade);

  // Corridor: long hallway behind doors
  const corridor = new THREE.Group();
  const length = 80; const width = 6; const height = 4.5;
  const floor = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, length), floorMat); floor.position.set(0, 0, -length/2);
  const ceil = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, length), wallMat); ceil.position.set(0, height, -length/2);
  const wallL = new THREE.Mesh(new THREE.BoxGeometry(0.2, height, length), wallMat); wallL.position.set(-width/2, height/2, -length/2);
  const wallR = new THREE.Mesh(new THREE.BoxGeometry(0.2, height, length), wallMat); wallR.position.set(width/2, height/2, -length/2);
  corridor.add(floor, ceil, wallL, wallR);
  corridor.position.set(0, 0, -0.4); // just behind doors
  scene.add(corridor);

  // Decorative trims near door
  const threshold = new THREE.Mesh(new THREE.BoxGeometry(width, 0.1, 0.4), trimMat); threshold.position.set(0, 0.1, -0.2);
  scene.add(threshold);

  // Frames along corridor walls
  const frameGroup = new THREE.Group();
  const loader = new THREE.TextureLoader();
  const framesPerSide = Math.ceil(PHOTOS.length/2);
  const spacing = 6; // distance between frames
  const frameW = 2.2, frameH = 1.5, frameDepth = 0.1;

  function makeFrame(tex, caption){
    const group = new THREE.Group();
    // wood frame
    const outer = new THREE.Mesh(new THREE.BoxGeometry(frameW, frameH, frameDepth), trimMat);
    // inner picture plane, slightly inset
    const picGeom = new THREE.PlaneGeometry(frameW*0.86, frameH*0.86);
    const picMat = new THREE.MeshBasicMaterial({ map: tex, toneMapped: false });
    const pic = new THREE.Mesh(picGeom, picMat);
    pic.position.z = frameDepth/2 + 0.002;

    // small plaque below
    const plaque = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.12, 0.05), trimMat);
    plaque.position.set(0, -frameH/2 - 0.18, frameDepth/2);

    group.userData = { caption, img: tex.image?.src || '' };
    group.add(outer, pic, plaque);
    return group;
  }

  // Load all textures then build frames
  const loading = document.getElementById('loading');
  const mngr = new THREE.LoadingManager(() => {
    loading.style.display = 'none';
    renderer.setAnimationLoop(animate);
  });
  const tLoader = new THREE.TextureLoader(mngr);

  const texArr = PHOTOS.map(p => new Promise(res => {
    tLoader.load(p.src + (p.src.includes('?')?'&':'?')+'auto=format&fit=crop', tex => { tex.colorSpace = THREE.SRGBColorSpace; res({tex, caption:p.caption}); });
  }));

  Promise.all(texArr).then(items => {
    items.forEach((it, i) => {
      const f = makeFrame(it.tex, it.caption);
      const idx = Math.floor(i/2);
      const side = (i % 2 === 0) ? -1 : 1; // left/right
      const z = -4 - idx*spacing; // push down corridor
      f.position.set(side*(width/2 - 0.4), 2.4, z);
      f.rotation.y = side>0 ? -Math.PI/2 : Math.PI/2;
      frameGroup.add(f);
    });
    corridor.add(frameGroup);
  });

  // Subtle floating dust particles
  const dustGeo = new THREE.BufferGeometry();
  const dustCount = 400;
  const pos = new Float32Array(dustCount*3);
  for(let i=0;i<dustCount;i++){
    pos[i*3+0] = (Math.random()-0.5)*width*0.9;
    pos[i*3+1] = Math.random()*height*0.95 + 0.2;
    pos[i*3+2] = -Math.random()*length;
  }
  dustGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const dustMat = new THREE.PointsMaterial({ size: 0.03, color: 0xffeecc, transparent:true, opacity:0.7 });
  const dust = new THREE.Points(dustGeo, dustMat);
  corridor.add(dust);

  // Raycaster for interactions
  const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
  let doorsOpened = false; let opening = false; let journey = 0; // 0..1 camera move

  function onPointer(e){
    const x = (e.clientX || e.touches?.[0]?.clientX || 0);
    const y = (e.clientY || e.touches?.[0]?.clientY || 0);
    mouse.x = (x / innerWidth) * 2 - 1;
    mouse.y = -(y / innerHeight) * 2 + 1;

    ray.setFromCamera(mouse, camera);
    const intersects = ray.intersectObjects([doorLeft, doorRight, ...frameGroup.children], true);
    if(!intersects.length) return;

    const first = intersects[0].object;
    // If door clicked and not opened -> open
    if(!doorsOpened && (first === doorLeft || first === doorRight || first.parent === doorLeft || first.parent === doorRight)){
      startOpenSequence();
      return;
    }

    // If a frame (or its child) clicked -> open lightbox with its image
    let node = first;
    while(node && !node.userData?.img){ node = node.parent; }
    if(node && node.userData?.img){ openLightbox(node.userData.img, node.userData.caption); }
  }
  window.addEventListener('click', onPointer);
  window.addEventListener('touchend', onPointer, {passive:true});

  // Open sequence: swing doors & move camera forward into corridor
  function startOpenSequence(){
    if(opening) return; opening = true; document.getElementById('hint').style.display='none';
    // animate over ~4.5s
    const t0 = performance.now();
    const dur = 4500;
    const startCam = camera.position.clone();
    const endCam = new THREE.Vector3(0, 2.2, -16);

    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

    function step(now){
      const t = Math.min(1, (now - t0)/dur);
      const e = easeOutCubic(t);
      // doors rotate ~90 degrees
      hingeL.rotation.y = THREE.MathUtils.lerp(0, Math.PI/2, e);
      hingeR.rotation.y = THREE.MathUtils.lerp(0, -Math.PI/2, e);
      // camera move
      camera.position.lerpVectors(startCam, endCam, e);
      camera.lookAt(0, 2.2, -24);

      // warm corridor light grows
      keyLight.intensity = 1.2 + e*1.6;

      if(t < 1){ requestAnimationFrame(step); }
      else { doorsOpened = true; controls.enabled = true; opening = false; }
    }
    requestAnimationFrame(step);
  }

  // Reset button
  document.getElementById('btnReset').addEventListener('click', () => {
    doorsOpened = false; opening = false; hingeL.rotation.y = 0; hingeR.rotation.y = 0;
    camera.position.set(0, 2, 14); camera.lookAt(0, 2, 0);
    controls.enabled = false; keyLight.intensity = 2;
    document.getElementById('hint').style.display='block';
  });

  // Lightbox logic
  const lb = document.getElementById('lightbox');
  const lbImg = document.getElementById('lbImg');
  const lbCap = document.getElementById('lbCaption');
  const lbClose = document.getElementById('lbClose');
  function openLightbox(src, cap){ lbImg.src = src; lbCap.textContent = cap || 'Happy Birthday!'; lb.classList.add('open'); lb.setAttribute('aria-hidden','false'); }
  function closeLightbox(){ lb.classList.remove('open'); lb.setAttribute('aria-hidden','true'); }
  lbClose.addEventListener('click', closeLightbox);
  lb.addEventListener('click', (e)=>{ if(e.target === lb) closeLightbox(); });
  document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeLightbox(); });

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Animation loop
  function animate(){
    controls.update();
    // gentle dust float
    const arr = dust.geometry.attributes.position.array;
    for(let i=0;i<dustCount;i++){
      const j = i*3+1; // y
      arr[j] += Math.sin((performance.now()*0.001 + i)*0.3) * 0.0006;
    }
    dust.geometry.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
  }
  </script>
</body>
</html>
